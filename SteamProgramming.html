<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw);.lst-kix_7v9xbf7bl7mx-4>li:before{content:"\0025cb   "}.lst-kix_hb3gbfyrv0nw-4>li{counter-increment:lst-ctn-kix_hb3gbfyrv0nw-4}.lst-kix_7v9xbf7bl7mx-3>li:before{content:"\0025cf   "}.lst-kix_7v9xbf7bl7mx-5>li:before{content:"\0025a0   "}.lst-kix_hb3gbfyrv0nw-8>li:before{content:"" counter(lst-ctn-kix_hb3gbfyrv0nw-8,lower-roman) ". "}.lst-kix_7v9xbf7bl7mx-2>li:before{content:"\0025a0   "}.lst-kix_7v9xbf7bl7mx-6>li:before{content:"\0025cf   "}.lst-kix_49i3chxix5ac-2>li{counter-increment:lst-ctn-kix_49i3chxix5ac-2}ol.lst-kix_hb3gbfyrv0nw-6.start{counter-reset:lst-ctn-kix_hb3gbfyrv0nw-6 0}.lst-kix_hb3gbfyrv0nw-7>li:before{content:"" counter(lst-ctn-kix_hb3gbfyrv0nw-7,lower-latin) ". "}ol.lst-kix_49i3chxix5ac-6.start{counter-reset:lst-ctn-kix_49i3chxix5ac-6 0}.lst-kix_hb3gbfyrv0nw-1>li:before{content:"" counter(lst-ctn-kix_hb3gbfyrv0nw-1,lower-latin) ". "}ol.lst-kix_hb3gbfyrv0nw-2.start{counter-reset:lst-ctn-kix_hb3gbfyrv0nw-2 0}ol.lst-kix_49i3chxix5ac-2.start{counter-reset:lst-ctn-kix_49i3chxix5ac-2 0}.lst-kix_49i3chxix5ac-7>li{counter-increment:lst-ctn-kix_49i3chxix5ac-7}.lst-kix_hb3gbfyrv0nw-0>li:before{content:"" counter(lst-ctn-kix_hb3gbfyrv0nw-0,decimal) ". "}ol.lst-kix_hb3gbfyrv0nw-0{list-style-type:none}.lst-kix_49i3chxix5ac-3>li{counter-increment:lst-ctn-kix_49i3chxix5ac-3}.lst-kix_7v9xbf7bl7mx-0>li:before{content:"\0025cf   "}ol.lst-kix_hb3gbfyrv0nw-3{list-style-type:none}ol.lst-kix_hb3gbfyrv0nw-4{list-style-type:none}.lst-kix_7v9xbf7bl7mx-1>li:before{content:"\0025cb   "}ol.lst-kix_hb3gbfyrv0nw-1{list-style-type:none}.lst-kix_hb3gbfyrv0nw-3>li{counter-increment:lst-ctn-kix_hb3gbfyrv0nw-3}ol.lst-kix_hb3gbfyrv0nw-2{list-style-type:none}ol.lst-kix_hb3gbfyrv0nw-7{list-style-type:none}ol.lst-kix_hb3gbfyrv0nw-8{list-style-type:none}ol.lst-kix_hb3gbfyrv0nw-5{list-style-type:none}ol.lst-kix_hb3gbfyrv0nw-6{list-style-type:none}.lst-kix_49i3chxix5ac-3>li:before{content:"" counter(lst-ctn-kix_49i3chxix5ac-3,decimal) ". "}.lst-kix_49i3chxix5ac-2>li:before{content:"" counter(lst-ctn-kix_49i3chxix5ac-2,lower-roman) ". "}.lst-kix_49i3chxix5ac-4>li:before{content:"" counter(lst-ctn-kix_49i3chxix5ac-4,lower-latin) ". "}.lst-kix_49i3chxix5ac-1>li:before{content:"" counter(lst-ctn-kix_49i3chxix5ac-1,lower-latin) ". "}.lst-kix_49i3chxix5ac-5>li:before{content:"" counter(lst-ctn-kix_49i3chxix5ac-5,lower-roman) ". "}ol.lst-kix_49i3chxix5ac-5.start{counter-reset:lst-ctn-kix_49i3chxix5ac-5 0}.lst-kix_49i3chxix5ac-6>li{counter-increment:lst-ctn-kix_49i3chxix5ac-6}ol.lst-kix_49i3chxix5ac-0{list-style-type:none}ol.lst-kix_49i3chxix5ac-2{list-style-type:none}ol.lst-kix_hb3gbfyrv0nw-7.start{counter-reset:lst-ctn-kix_hb3gbfyrv0nw-7 0}ol.lst-kix_49i3chxix5ac-1{list-style-type:none}.lst-kix_49i3chxix5ac-4>li{counter-increment:lst-ctn-kix_49i3chxix5ac-4}.lst-kix_hb3gbfyrv0nw-2>li:before{content:"" counter(lst-ctn-kix_hb3gbfyrv0nw-2,lower-roman) ". "}.lst-kix_49i3chxix5ac-1>li{counter-increment:lst-ctn-kix_49i3chxix5ac-1}.lst-kix_hb3gbfyrv0nw-2>li{counter-increment:lst-ctn-kix_hb3gbfyrv0nw-2}.lst-kix_hb3gbfyrv0nw-3>li:before{content:"" counter(lst-ctn-kix_hb3gbfyrv0nw-3,decimal) ". "}.lst-kix_hb3gbfyrv0nw-8>li{counter-increment:lst-ctn-kix_hb3gbfyrv0nw-8}.lst-kix_49i3chxix5ac-0>li:before{content:"" counter(lst-ctn-kix_49i3chxix5ac-0,decimal) ". "}.lst-kix_hb3gbfyrv0nw-5>li{counter-increment:lst-ctn-kix_hb3gbfyrv0nw-5}ol.lst-kix_hb3gbfyrv0nw-1.start{counter-reset:lst-ctn-kix_hb3gbfyrv0nw-1 0}.lst-kix_hb3gbfyrv0nw-4>li:before{content:"" counter(lst-ctn-kix_hb3gbfyrv0nw-4,lower-latin) ". "}.lst-kix_hb3gbfyrv0nw-6>li:before{content:"" counter(lst-ctn-kix_hb3gbfyrv0nw-6,decimal) ". "}ol.lst-kix_49i3chxix5ac-8.start{counter-reset:lst-ctn-kix_49i3chxix5ac-8 0}.lst-kix_hb3gbfyrv0nw-5>li:before{content:"" counter(lst-ctn-kix_hb3gbfyrv0nw-5,lower-roman) ". "}.lst-kix_hb3gbfyrv0nw-7>li{counter-increment:lst-ctn-kix_hb3gbfyrv0nw-7}.lst-kix_49i3chxix5ac-5>li{counter-increment:lst-ctn-kix_49i3chxix5ac-5}.lst-kix_hb3gbfyrv0nw-1>li{counter-increment:lst-ctn-kix_hb3gbfyrv0nw-1}ol.lst-kix_hb3gbfyrv0nw-4.start{counter-reset:lst-ctn-kix_hb3gbfyrv0nw-4 0}ol.lst-kix_49i3chxix5ac-1.start{counter-reset:lst-ctn-kix_49i3chxix5ac-1 0}ol.lst-kix_49i3chxix5ac-4{list-style-type:none}ul.lst-kix_7v9xbf7bl7mx-5{list-style-type:none}ol.lst-kix_hb3gbfyrv0nw-8.start{counter-reset:lst-ctn-kix_hb3gbfyrv0nw-8 0}ol.lst-kix_49i3chxix5ac-3{list-style-type:none}ul.lst-kix_7v9xbf7bl7mx-4{list-style-type:none}ol.lst-kix_49i3chxix5ac-6{list-style-type:none}ul.lst-kix_7v9xbf7bl7mx-3{list-style-type:none}ol.lst-kix_49i3chxix5ac-5{list-style-type:none}ul.lst-kix_7v9xbf7bl7mx-2{list-style-type:none}ol.lst-kix_49i3chxix5ac-8{list-style-type:none}ul.lst-kix_7v9xbf7bl7mx-1{list-style-type:none}.lst-kix_hb3gbfyrv0nw-6>li{counter-increment:lst-ctn-kix_hb3gbfyrv0nw-6}ol.lst-kix_49i3chxix5ac-7{list-style-type:none}ul.lst-kix_7v9xbf7bl7mx-0{list-style-type:none}.lst-kix_49i3chxix5ac-7>li:before{content:"" counter(lst-ctn-kix_49i3chxix5ac-7,lower-latin) ". "}ol.lst-kix_49i3chxix5ac-4.start{counter-reset:lst-ctn-kix_49i3chxix5ac-4 0}.lst-kix_49i3chxix5ac-6>li:before{content:"" counter(lst-ctn-kix_49i3chxix5ac-6,decimal) ". "}.lst-kix_49i3chxix5ac-8>li:before{content:"" counter(lst-ctn-kix_49i3chxix5ac-8,lower-roman) ". "}ol.lst-kix_hb3gbfyrv0nw-0.start{counter-reset:lst-ctn-kix_hb3gbfyrv0nw-0 0}ul.lst-kix_7v9xbf7bl7mx-8{list-style-type:none}.lst-kix_49i3chxix5ac-0>li{counter-increment:lst-ctn-kix_49i3chxix5ac-0}ul.lst-kix_7v9xbf7bl7mx-7{list-style-type:none}ul.lst-kix_7v9xbf7bl7mx-6{list-style-type:none}.lst-kix_hb3gbfyrv0nw-0>li{counter-increment:lst-ctn-kix_hb3gbfyrv0nw-0}ol.lst-kix_hb3gbfyrv0nw-5.start{counter-reset:lst-ctn-kix_hb3gbfyrv0nw-5 0}ol.lst-kix_49i3chxix5ac-0.start{counter-reset:lst-ctn-kix_49i3chxix5ac-0 0}ol.lst-kix_49i3chxix5ac-7.start{counter-reset:lst-ctn-kix_49i3chxix5ac-7 0}ol.lst-kix_hb3gbfyrv0nw-3.start{counter-reset:lst-ctn-kix_hb3gbfyrv0nw-3 0}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ol.lst-kix_49i3chxix5ac-3.start{counter-reset:lst-ctn-kix_49i3chxix5ac-3 0}.lst-kix_7v9xbf7bl7mx-8>li:before{content:"\0025a0   "}.lst-kix_7v9xbf7bl7mx-7>li:before{content:"\0025cb   "}.lst-kix_49i3chxix5ac-8>li{counter-increment:lst-ctn-kix_49i3chxix5ac-8}ol{margin:0;padding:0}table td,table th{padding:0}.c26{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#333333;border-left-style:solid;border-bottom-width:0pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c15{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c5{background-color:#1f1f1f;padding-top:0pt;padding-bottom:0pt;line-height:1.3571428571428572;orphans:2;widows:2;text-align:left}.c20{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c9{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c16{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c28{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c8{font-size:10.5pt;font-family:"Consolas";color:#c586c0;font-weight:400}.c13{color:#6a9955;font-weight:400;font-size:10.5pt;font-family:"Consolas"}.c11{font-size:10.5pt;font-family:"Consolas";color:#dcdcaa;font-weight:400}.c31{border-spacing:0;border-collapse:collapse;margin-right:auto}.c2{font-size:10.5pt;font-family:"Consolas";color:#9cdcfe;font-weight:400}.c27{background-color:#333333;font-family:"Consolas";color:#888888;font-weight:400}.c14{background-color:#333333;font-family:"Consolas";color:#d36363;font-weight:400}.c23{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c22{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c25{color:#434343;font-weight:400;font-size:14pt;font-family:"Arial"}.c3{font-size:10.5pt;font-family:"Consolas";color:#b5cea8;font-weight:400}.c1{font-size:10.5pt;font-family:"Consolas";color:#d4d4d4;font-weight:400}.c17{background-color:#333333;font-family:"Consolas";color:#fcc28c;font-weight:400}.c35{color:#000000;font-weight:400;font-size:20pt;font-family:"Arial"}.c4{font-size:10.5pt;font-family:"Consolas";color:#4ec9b0;font-weight:400}.c0{font-size:10.5pt;font-family:"Consolas";color:#cccccc;font-weight:400}.c33{background-color:#333333;font-family:"Consolas";color:#a2fca2;font-weight:400}.c19{background-color:#333333;font-family:"Consolas";color:#ffffff;font-weight:400}.c10{font-size:10.5pt;font-family:"Consolas";color:#569cd6;font-weight:400}.c34{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c12{text-decoration:none;vertical-align:baseline;font-style:normal}.c29{padding:0;margin:0}.c21{color:inherit;text-decoration:inherit}.c24{height:16pt}.c30{height:0pt}.c18{height:11pt}.c32{vertical-align:super}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c34 doc-content"><h1 class="c28" id="h.n436fkts8cx8"><span class="c12 c35">Programming Tasks</span></h1><h2 class="c9" id="h.hhrug2kq4gxa"><span class="c6">Intro</span></h2><p class="c16"><span class="c7">Each of the assignments below will be placed into a separate &ldquo;effect&rdquo; function inside the source code for WLED. &nbsp;This will allow you to select these effects in the UI and see if they work the way you intended. &nbsp;You can find the empty effect function for each task in FX.cpp starting on line 896. &nbsp;They are named mode_steam1, mode_steam2, &hellip;, mode_steam5.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span>In order to test your code, you can use the bash shell window to run the </span><span class="c22"><a class="c21" href="https://www.google.com/url?q=http://build.sh&amp;sa=D&amp;source=editors&amp;ust=1746804972583792&amp;usg=AOvVaw0r_Dv1wjUecNJ98P-mxOaO">build.sh</a></span><span class="c7">&nbsp;script.</span></p><table class="c31"><tr class="c30"><td class="c26" colspan="1" rowspan="1"><p class="c23"><span class="c19">$ ./build.sh</span></p></td></tr></table><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">This will build the project and show you any errors in your code. &nbsp;If it works the output will end like this:</span></p><table class="c31"><tr class="c30"><td class="c26" colspan="1" rowspan="1"><p class="c23"><span class="c19">Building in </span><span class="c17">release</span><span class="c19">&nbsp;</span><span class="c17">mode</span><span class="c19"><br>Retrieving maximum program </span><span class="c17">size</span><span class="c19">&nbsp;.pio\</span><span class="c17">build</span><span class="c19">\esp32dev\firmware.elf<br>Checking </span><span class="c17">size</span><span class="c19">&nbsp;.pio\</span><span class="c17">build</span><span class="c19">\esp32dev\firmware.elf<br></span><span class="c17">Advanced</span><span class="c19">&nbsp;</span><span class="c17">Memory</span><span class="c19">&nbsp;</span><span class="c17">Usage</span><span class="c19">&nbsp;</span><span class="c17">is</span><span class="c19">&nbsp;available via </span><span class="c33">&quot;PlatformIO Home &gt; Project Inspect&quot;</span><span class="c19"><br>RAM: &nbsp; [= &nbsp; &nbsp; &nbsp; &nbsp; ] &nbsp;</span><span class="c14">14.7</span><span class="c19">% (used </span><span class="c14">48160</span><span class="c19">&nbsp;</span><span class="c17">bytes</span><span class="c19">&nbsp;</span><span class="c17">from</span><span class="c19">&nbsp;</span><span class="c14">327680</span><span class="c19">&nbsp;</span><span class="c17">bytes</span><span class="c19">)<br>Flash: [========= ] &nbsp;</span><span class="c14">86.1</span><span class="c19">% (used </span><span class="c14">1354345</span><span class="c19">&nbsp;</span><span class="c17">bytes</span><span class="c19">&nbsp;</span><span class="c17">from</span><span class="c19">&nbsp;</span><span class="c14">1572864</span><span class="c19">&nbsp;</span><span class="c17">bytes</span><span class="c19">)<br>============================================== [</span><span class="c17">SUCCESS</span><span class="c19">] Took </span><span class="c14">14.90</span><span class="c19">&nbsp;seconds ===========================================================================<br><br>Environment &nbsp; &nbsp;</span><span class="c17">Status</span><span class="c19">&nbsp; &nbsp; </span><span class="c17">Duration</span><span class="c19"><br></span><span class="c27">------------- &nbsp;-------- &nbsp;------------</span><span class="c19"><br>esp32dev &nbsp; &nbsp; &nbsp; </span><span class="c17">SUCCESS</span><span class="c19">&nbsp; &nbsp;</span><span class="c14">00</span><span class="c19">:</span><span class="c14">00</span><span class="c19">:</span><span class="c14">14.903</span><span class="c19"><br>============================================== </span><span class="c14">1</span><span class="c19">&nbsp;succeeded </span><span class="c17">in</span><span class="c19">&nbsp;</span><span class="c14">00</span><span class="c19">:</span><span class="c14">00</span><span class="c19">:</span><span class="c14">14.903</span><span class="c19">&nbsp;===========================================================================<br></span></p></td></tr></table><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span>When you are ready to test your code on the LED wall then you can use the </span><span class="c22"><a class="c21" href="https://www.google.com/url?q=http://upload.sh&amp;sa=D&amp;source=editors&amp;ust=1746804972589078&amp;usg=AOvVaw0cOofM4RfYC6t3084omzRN">upload.sh</a></span><span class="c7">&nbsp;script to upload the compiled code to the LED controller.</span></p><table class="c31"><tr class="c30"><td class="c26" colspan="1" rowspan="1"><p class="c23"><span class="c19">$ ./upload.sh</span></p></td></tr></table><hr style="page-break-before:always;display:none;"><p class="c16 c18"><span class="c7"></span></p><h2 class="c9" id="h.e333l95ayc10"><span class="c6">Task 1 - Color Some Pixels</span></h2><p class="c16"><span class="c7">Task 1 will be coded into the mode_steam1 function. &nbsp;Here we are just going to set a few pixels to custom colors. &nbsp;The setPixelColorXY function takes three parameters:</span></p><ul class="c29 lst-kix_7v9xbf7bl7mx-0 start"><li class="c15 li-bullet-0"><span class="c7">x - This is the horizontal coordinate. &nbsp;0 is the left most column and 19 is the right most column.</span></li><li class="c15 li-bullet-0"><span class="c7">y - This is the vertical coordinate. &nbsp;0 is the top row and 19 is the bottom row.</span></li><li class="c15 li-bullet-0"><span class="c7">color - This is a 32bit color built using the RGBW macro. &nbsp;The macro takes r,g,b and w components. &nbsp;Our leds don&rsquo;t have a w LED so you can leave that as 0. The r, g, and b parameters control the strength of the red, green, and blue LEDS respectively. &nbsp;0 is off (so black) and 255 is full brightness. </span></li></ul><table class="c31"><tr class="c30"><td class="c26" colspan="1" rowspan="1"><p class="c23"><span class="c19">strip.setPixelColorXY(</span><span class="c14">3</span><span class="c19">, &nbsp;</span><span class="c14">3</span><span class="c19">, RGBW32(</span><span class="c14">255</span><span class="c19">, </span><span class="c14">0</span><span class="c19">, </span><span class="c14">0</span><span class="c19">, </span><span class="c14">0</span><span class="c19">)); &nbsp;// Set 3,3 to Red<br>strip.setPixelColorXY(</span><span class="c14">10</span><span class="c19">, </span><span class="c14">2</span><span class="c19">, RGBW32(</span><span class="c14">0</span><span class="c19">, </span><span class="c14">255</span><span class="c19">, </span><span class="c14">0</span><span class="c19">, </span><span class="c14">0</span><span class="c19">)); &nbsp;// Set 10, 2 to Green<br>strip.setPixelColorXY(</span><span class="c14">2</span><span class="c19">, </span><span class="c14">10</span><span class="c19">, RGBW32(</span><span class="c14">0</span><span class="c19">, </span><span class="c14">0</span><span class="c19">, </span><span class="c14">255</span><span class="c19">, </span><span class="c14">0</span><span class="c19">)); &nbsp;// Set 2, 10 to Blue</span></p></td></tr></table><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Add a few strip.setPixelColorXY calls to the mode_steam1 function. &nbsp; Use different colors for each pixel. &nbsp;Be sure the x and y are between 0 and 19 and the r, g, and b are between 0 and 255.</span></p><hr style="page-break-before:always;display:none;"><h2 class="c9 c24" id="h.vobhl7wxjx1n"><span class="c6"></span></h2><h2 class="c9" id="h.etkxa982wfkp"><span class="c6">Task 2 - Color the Odds</span></h2><p class="c16"><span class="c7">Task 2 will be coded into the mode_steam2 function. &nbsp;For this task we are going to loop through all the rows and set the odd rows to the foreground color. &nbsp;</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">The first step is to loop through all the rows. &nbsp;The for loop in C++ looks like this:</span></p><p class="c5"><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">; </span><span class="c2">y</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0 c12">}</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Here we create a new variable y. &nbsp;We initialize the variable to 0. &nbsp;We tell the loop to continue as long as y &lt; 20. &nbsp;Then after each iteration we use y++ to increment y by 1.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Now we only want to color the odd rows. &nbsp;We use an if statement to run the row color code only for odd rows. &nbsp;We use the condition (y % 2) == 1 to detect odd rows. &nbsp;The % operator is the modulus operator in C++. &nbsp;This means divide y by 2 and output the remainder. &nbsp;So y % 2 will be 0 for even numbers (since there is no remainder) and 1 for odd numbers.</span></p><p class="c5"><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">; </span><span class="c2">y</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;((</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">%</span><span class="c0">&nbsp;</span><span class="c3">2</span><span class="c0">) </span><span class="c1">==</span><span class="c0">&nbsp;</span><span class="c3">1</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0">&nbsp; }</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Now we need to add code to set the pixels of the current row to the foreground color. &nbsp;We do this with a new loop using the x variable starting at x=0 and continuing as long as x &lt; 20.</span></p><p class="c16"><span class="c7">WLED lets the user select a foreground color in the web UI. &nbsp;We can obtain this color using the fg() function call. &nbsp;Inside our loop we add a setPixelColorXY call with x, y and the foreground color. &nbsp;So our final code looks like this.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">; </span><span class="c2">y</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;((</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">%</span><span class="c0">&nbsp;</span><span class="c3">2</span><span class="c0">) </span><span class="c1">==</span><span class="c0">&nbsp;</span><span class="c3">1</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">x</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">; </span><span class="c2">x</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">setPixelColorXY</span><span class="c0">(</span><span class="c2">x</span><span class="c0">, </span><span class="c2">y</span><span class="c0">, </span><span class="c11">fg</span><span class="c0 c12">());</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><hr style="page-break-before:always;display:none;"><h2 class="c9 c24" id="h.1owu9alvpw6t"><span class="c6"></span></h2><h2 class="c9" id="h.uk0ej37bpm6h"><span class="c6">Task3 - Palette</span></h2><p class="c16"><span class="c7">For task 3 we are going to color each row according to the color palette the user selected in the UI. &nbsp;The color palette is a collection of 256 colors. &nbsp;Most of the palettes are smooth gradients. &nbsp;We want the top row to be at palette color 0 and the bottom row to be at palette color 255.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">The code will look very similar to task 2. &nbsp;We need to loop over every row and every column in those rows. &nbsp;We can remove the odd row detection since now we are coloring every row.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">; </span><span class="c2">y</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">x</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">; </span><span class="c2">x</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">setPixelColorXY</span><span class="c0">(</span><span class="c2">x</span><span class="c0">, </span><span class="c2">y</span><span class="c0">, </span><span class="c11">fg</span><span class="c0 c12">());</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0">&nbsp; }</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Now the new piece is a calculation to determine what color to use. &nbsp;First we calculate the index from 0 - 255 in the palette. &nbsp;This is simply scaling 0-19 to 0-255.</span></p><p class="c5"><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c2">index</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c3">255</span><span class="c0">&nbsp;</span><span class="c1">/</span><span class="c0">&nbsp;</span><span class="c3">19</span><span class="c0 c12">;</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Once we have an index we can use the color_from_palette function to get the color. &nbsp;Ignore the (false, true, 3) parameters as they are somewhat complicated and (false, true, 3) is always what we want.</span></p><p class="c5"><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">c</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">color_from_palette</span><span class="c0">(</span><span class="c2">index</span><span class="c0">, </span><span class="c10">false</span><span class="c0">, </span><span class="c10">true</span><span class="c0">, </span><span class="c3">3</span><span class="c0 c12">);</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">This new code needs to be done only every row. &nbsp;Then we can also change &ldquo;fg()&rdquo; to &ldquo;c&rdquo; in the setPixelColorXY call. &nbsp;The final code looks like this:</span></p><p class="c5"><span class="c0">&nbsp;</span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">; </span><span class="c2">y</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">c</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">color_from_palette</span><span class="c0">(</span><span class="c2">index</span><span class="c0">, </span><span class="c10">false</span><span class="c0">, </span><span class="c10">true</span><span class="c0">, </span><span class="c3">3</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">x</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">; </span><span class="c2">x</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">setPixelColorXY</span><span class="c0">(</span><span class="c2">x</span><span class="c0">, </span><span class="c2">y</span><span class="c0">, </span><span class="c11">c</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c16 c18"><span class="c7"></span></p><hr style="page-break-before:always;display:none;"><h2 class="c9 c24" id="h.3acxs0m0nut"><span class="c6"></span></h2><h2 class="c9" id="h.3ztyflnlsytv"><span class="c6">Task 4 - Moving Palette</span></h2><p class="c16"><span class="c7">For task 4 we will make the colors from task 3 rotate through the palette over time. &nbsp;This will give the impression that the LED wall is scrolling upwards.</span></p><p class="c16"><span>WLED gives you a notion of time as a single number using the strip.now variable. &nbsp;This number counts very fast so we generally need to make it much smaller before using it to make our effects move. &nbsp;The user is also able to set a speed for the current effect. &nbsp;We can obtain this speed from the SEGMENT.speed variable. &nbsp;In order to combine these we just multiply them together. &nbsp;So a larger speed will result in a larger number. &nbsp;Then to account for strip.now counting so fast we will use the &gt;&gt; operator to shift the result down by 12 bits. &nbsp;This is the equivalent of dividing the result by &nbsp;2</span><span class="c32">12</span><span class="c7">&nbsp;but is much faster for the CPU to do. &nbsp;The final calculation looks like this:</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;(</span><span class="c2">strip</span><span class="c0">.</span><span class="c2">now</span><span class="c0">&nbsp;</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">speed</span><span class="c0">) </span><span class="c1">&gt;&gt;</span><span class="c0">&nbsp;</span><span class="c3">12</span><span class="c0 c12">;</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">This gives us a counter variable that will continuously count up at a rate based on the user&rsquo;s speed selection in the UI. &nbsp;We can then combine this with our previous calculation to get a palette index that changes over time:</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c2">index</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;((</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c3">255</span><span class="c0">&nbsp;</span><span class="c1">/</span><span class="c0">&nbsp;</span><span class="c3">19</span><span class="c0">) </span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0">) </span><span class="c1">%</span><span class="c0">&nbsp;</span><span class="c3">256</span><span class="c0 c12">;</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">The final code then looks like this:</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c4">&nbsp; uint32_t</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;(</span><span class="c2">strip</span><span class="c0">.</span><span class="c2">now</span><span class="c0">&nbsp;</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">speed</span><span class="c0">) </span><span class="c1">&gt;&gt;</span><span class="c0">&nbsp;</span><span class="c3">12</span><span class="c0 c12">;</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">; </span><span class="c2">y</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c2">index</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;((</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c3">255</span><span class="c0">&nbsp;</span><span class="c1">/</span><span class="c0">&nbsp;</span><span class="c3">19</span><span class="c0">) </span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0">) </span><span class="c1">%</span><span class="c0">&nbsp;</span><span class="c3">256</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">c</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">color_from_palette</span><span class="c0">(</span><span class="c2">index</span><span class="c0">, </span><span class="c10">false</span><span class="c0">, </span><span class="c10">true</span><span class="c0">, </span><span class="c3">3</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">x</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">; </span><span class="c2">x</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">setPixelColorXY</span><span class="c0">(</span><span class="c2">x</span><span class="c0">, </span><span class="c2">y</span><span class="c0">, </span><span class="c2">c</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><hr style="page-break-before:always;display:none;"><h2 class="c9 c24" id="h.e8pkneea3qgh"><span class="c6"></span></h2><h2 class="c9" id="h.mvkd0lc4t2ty"><span class="c6">Task 5 - Colored Rain</span></h2><p class="c16"><span class="c7">Task 5 is going to be more complicated. &nbsp;We want to have multi-colored raindrops that fall down the screen. &nbsp;To do this we are going to need a few new things.</span></p><ol class="c29 lst-kix_49i3chxix5ac-0 start" start="1"><li class="c15 li-bullet-0"><span class="c7">We need some way to remember where each raindrop is and what color it is.</span></li><li class="c15 li-bullet-0"><span class="c7">We need to be able to put the raindrops in random locations. &nbsp;If they are all lined up then it will look silly.</span></li><li class="c15 li-bullet-0"><span class="c7">We need to know when our counter ticks to a new value so we can move the raindrops. &nbsp;We can&rsquo;t move them every time we draw them as that would be way too fast.</span></li></ol><h3 class="c20" id="h.4nkljv2zoi4l"><span class="c25 c12">Remembering the Raindrops</span></h3><p class="c16"><span class="c7">In order for the code to remember the raindrops we need some way to organize the information about each drop. &nbsp;In C++ the simplest way to do this is to use a struct. &nbsp;We can define a simple Drop struct with members x, y, speed, and color. &nbsp;These will tell us where the raindrop is on the screen, how fast it is falling, and what color index from the palette should be used to draw it. &nbsp;The new struct is defined outside of our function:</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c13 c12">// Number of raindrops</span></p><p class="c5"><span class="c8">#define</span><span class="c10">&nbsp;RAINDROPS </span><span class="c3 c12">20</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">// struct for steam5</span></p><p class="c5"><span class="c10">struct</span><span class="c0">&nbsp;</span><span class="c4">Drop</span><span class="c0 c12">&nbsp;{</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">x</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">speed</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">color</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">};</span></p><p class="c5 c18"><span class="c7"></span></p><p class="c5"><span class="c13 c12">// Colored rain.</span></p><p class="c5"><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c11">mode_steam5</span><span class="c0">(</span><span class="c10">void</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c13 c12">&nbsp; // Clear all the LEDS</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">fill</span><span class="c0">(</span><span class="c11">bg</span><span class="c0 c12">());</span></p><p class="c5"><span class="c0 c12">&nbsp;</span></p><p class="c5"><span class="c8">&nbsp; return</span><span class="c0">&nbsp;</span><span class="c10">FRAMETIME</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">}</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Now that we have a way to organize our information we need to allocate some memory to store the information. &nbsp;In WLED we can do this using the SEGMENT.allocateData function. &nbsp;We allocate enough memory to store RAINDROPS Drop structs.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c13 c12">&nbsp; // Allocate memory for the raindrop data.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c1">!</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">allocateData</span><span class="c0">(</span><span class="c10">sizeof</span><span class="c0">(</span><span class="c4">Drop</span><span class="c0">) </span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">RAINDROPS</span><span class="c0 c12">))</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">return</span><span class="c0">&nbsp;</span><span class="c11">mode_static</span><span class="c0">();</span><span class="c13 c12">&nbsp;//allocation failed</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Memory allocation is never a sure thing so if it fails we just revert to using mode_static which is the &ldquo;Solid&rdquo; effect in WLED.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Once we have the memory allocated we can declare a drops variable to let us access it.</span></p><p class="c16"><span class="c7">Your function at this point should look like this:</span></p><p class="c5"><span class="c13 c12">// Colored rain.</span></p><p class="c5"><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c11">mode_steam5</span><span class="c0">(</span><span class="c10">void</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c13 c12">&nbsp; // Clear all the LEDS</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">fill</span><span class="c0">(</span><span class="c11">bg</span><span class="c0 c12">());</span></p><p class="c5"><span class="c0 c12">&nbsp;</span></p><p class="c5"><span class="c13 c12">&nbsp; // Allocate memory for the raindrop data.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c1">!</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">allocateData</span><span class="c0">(</span><span class="c10">sizeof</span><span class="c0">(</span><span class="c4">Drop</span><span class="c0">) </span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">RAINDROPS</span><span class="c0 c12">))</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">return</span><span class="c0">&nbsp;</span><span class="c11">mode_static</span><span class="c0">();</span><span class="c13 c12">&nbsp;//allocation failed</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">Drop</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c2">drops</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">reinterpret_cast</span><span class="c1">&lt;</span><span class="c4">Drop</span><span class="c1">*&gt;</span><span class="c0">(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">data</span><span class="c0 c12">);</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c8">&nbsp; return</span><span class="c0">&nbsp;</span><span class="c10">FRAMETIME</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">}</span></p><h3 class="c20" id="h.vsdz16kphjdr"><span class="c25 c12">Randomizing the Raindrops</span></h3><p class="c16"><span class="c7">The first thing we need to do with our raindrops is to initialize them. &nbsp;When memory is allocated in C++ it may contain any old values so it is important to initialize the data to something that makes sense. &nbsp;In this case we want to randomize where the rain drops are, how fast they fall, and what color they are. &nbsp;We only do this if it is the first time we&rsquo;ve been called. &nbsp;We can get random numbers using the random8() function. &nbsp;By default it returns a number between 0 and 255. &nbsp;We can optionally pass it a max number and it will return 0 to max-1.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c13 c12">&nbsp; // Initialize the raindrops on the first call.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">call</span><span class="c0">&nbsp;</span><span class="c1">==</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">RAINDROPS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">20</span><span class="c0">);</span><span class="c13 c12">&nbsp; // 0-19</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">20</span><span class="c0">);</span><span class="c13 c12">&nbsp; // 0-19</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">2</span><span class="c0">) </span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">1</span><span class="c0">;</span><span class="c13 c12">&nbsp; // 1 or 2</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">();</span><span class="c13 c12">&nbsp;// 0 - 255</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0">&nbsp; }</span></p><p class="c16 c18"><span class="c7"></span></p><h3 class="c20" id="h.knzl01ing2qu"><span class="c12 c25">Drawing the Raindrops</span></h3><p class="c16"><span class="c7">Now that we have good data for the raindrops we can add a loop to draw each raindrop.</span></p><p class="c5"><span class="c13 c12">&nbsp; // Draw all the raindrops.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">RAINDROPS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">c</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">color_from_palette</span><span class="c0">(</span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">, </span><span class="c10">false</span><span class="c0">, </span><span class="c10">true</span><span class="c0">, </span><span class="c3">3</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">setPixelColorXY</span><span class="c0">(</span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">x</span><span class="c0">, </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">y</span><span class="c0">, </span><span class="c2">c</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c16 c18"><span class="c7"></span></p><h3 class="c20" id="h.ib75pfegjw2t"><span class="c25 c12">Moving the Raindrops</span></h3><p class="c16"><span class="c7">First we set up a counter. &nbsp;We also use SEGMENT.step to remember the last counter value. &nbsp;That way when it changes we can update the raindrops.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;(</span><span class="c2">strip</span><span class="c0">.</span><span class="c2">now</span><span class="c0">&nbsp;</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">speed</span><span class="c0">) </span><span class="c1">&gt;&gt;</span><span class="c0">&nbsp;</span><span class="c3">14</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c10">bool</span><span class="c0">&nbsp;</span><span class="c2">tick</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">false</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">step</span><span class="c0">&nbsp;</span><span class="c1">!=</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c2">tick</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">true</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">step</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Now whenever tick == true we can move the raindrops down. &nbsp;If a raindrop moves off the screen we reinitialize it using the same code as above. &nbsp;The only change is that we set the y to 0 so the raindrop will start at the top of the screen.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c2">tick</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c13 c12">&nbsp; &nbsp; // Update the positions of all the raindrops.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">RAINDROPS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">+=</span><span class="c0">&nbsp;</span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0 c12">;</span></p><p class="c5"><span class="c13 c12">&nbsp; &nbsp; &nbsp; // Check if the drop went off the screen and reset if it did.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&gt;=</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">20</span><span class="c0">);</span><span class="c13 c12">&nbsp; // 0-19</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">2</span><span class="c0">) </span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">1</span><span class="c0">;</span><span class="c13 c12">&nbsp; // 1 or 2</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">();</span><span class="c13 c12">&nbsp;// 0 - 255</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c16 c18"><span class="c7"></span></p><hr style="page-break-before:always;display:none;"><p class="c16 c18"><span class="c7"></span></p><p class="c16"><span class="c7">Putting it all together our task5 function looks like this:</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c13 c12">// Number of raindrops</span></p><p class="c5"><span class="c8">#define</span><span class="c10">&nbsp;RAINDROPS </span><span class="c3 c12">20</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">// struct for steam5</span></p><p class="c5"><span class="c10">struct</span><span class="c0">&nbsp;</span><span class="c4">Drop</span><span class="c0 c12">&nbsp;{</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">x</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">speed</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">color</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">};</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">// Colored rain.</span></p><p class="c5"><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c11">mode_steam5</span><span class="c0">(</span><span class="c10">void</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c13 c12">&nbsp; // Clear all the LEDS</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">fill</span><span class="c0">(</span><span class="c11">bg</span><span class="c0 c12">());</span></p><p class="c5"><span class="c0 c12">&nbsp;</span></p><p class="c5"><span class="c13 c12">&nbsp; // Allocate memory for the raindrop data.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c1">!</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">allocateData</span><span class="c0">(</span><span class="c10">sizeof</span><span class="c0">(</span><span class="c4">Drop</span><span class="c0">) </span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">RAINDROPS</span><span class="c0 c12">))</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">return</span><span class="c0">&nbsp;</span><span class="c11">mode_static</span><span class="c0">();</span><span class="c13 c12">&nbsp;//allocation failed</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">Drop</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c2">drops</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">reinterpret_cast</span><span class="c1">&lt;</span><span class="c4">Drop</span><span class="c1">*&gt;</span><span class="c0">(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">data</span><span class="c0 c12">);</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">&nbsp; // Initialize the raindrops on the first call.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">call</span><span class="c0">&nbsp;</span><span class="c1">==</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">RAINDROPS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">20</span><span class="c0">);</span><span class="c13 c12">&nbsp; // 0-19</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">20</span><span class="c0">);</span><span class="c13 c12">&nbsp; // 0-19</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">2</span><span class="c0">) </span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">1</span><span class="c0">;</span><span class="c13 c12">&nbsp; // 1 or 2</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">();</span><span class="c13 c12">&nbsp;// 0 - 255</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">&nbsp; // Draw all the raindrops.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">RAINDROPS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">c</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">color_from_palette</span><span class="c0">(</span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">, </span><span class="c10">false</span><span class="c0">, </span><span class="c10">true</span><span class="c0">, </span><span class="c3">3</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">setPixelColorXY</span><span class="c0">(</span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">x</span><span class="c0">, </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">y</span><span class="c0">, </span><span class="c2">c</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">&nbsp; // Setup a clock based on the speed and update drops only when it ticks over.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;(</span><span class="c2">strip</span><span class="c0">.</span><span class="c2">now</span><span class="c0">&nbsp;</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">speed</span><span class="c0">) </span><span class="c1">&gt;&gt;</span><span class="c0">&nbsp;</span><span class="c3">14</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c10">bool</span><span class="c0">&nbsp;</span><span class="c2">tick</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">false</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">step</span><span class="c0">&nbsp;</span><span class="c1">!=</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c2">tick</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">true</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">step</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c2">tick</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c13 c12">&nbsp; &nbsp; // Update the positions of all the raindrops.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">RAINDROPS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">+=</span><span class="c0">&nbsp;</span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0 c12">;</span></p><p class="c5"><span class="c12 c13">&nbsp; &nbsp; &nbsp; // Check if the drop went off the screen and reset if it did.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&gt;=</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">20</span><span class="c0">);</span><span class="c13 c12">&nbsp; // 0-19</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">2</span><span class="c0">) </span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">1</span><span class="c0">;</span><span class="c13 c12">&nbsp; // 1 or 2</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">drops</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">();</span><span class="c13 c12">&nbsp;// 0 - 255</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">return</span><span class="c0">&nbsp;</span><span class="c10">FRAMETIME</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">}</span></p><hr style="page-break-before:always;display:none;"><p class="c16 c18"><span class="c7"></span></p><h2 class="c9" id="h.8el80jv13ell"><span class="c6">Task 6 - Confetti</span></h2><p class="c16"><span class="c7">For task 6 we will make a similar effect to task 5 with a few key differences:</span></p><ol class="c29 lst-kix_hb3gbfyrv0nw-0 start" start="1"><li class="c15 li-bullet-0"><span class="c7">The drops will start in the center of the screen and move outward at a random angle.</span></li><li class="c15 li-bullet-0"><span class="c7">The drops will all be synchronized so they appear to explode outward.</span></li><li class="c15 li-bullet-0"><span class="c7">There will be more variance in the speed of the drops.</span></li></ol><p class="c16 c18"><span class="c7"></span></p><h3 class="c20" id="h.9lk93rmts3u6"><span class="c25 c12">Setup</span></h3><p class="c16"><span class="c7">The initial setup is very similar to task 5. &nbsp;Here is the setup that covers the struct to store the data and the allocation of memory for the data. &nbsp;Here we call the moving pieces Bits. &nbsp;The code is the same as in task 5 except we call the things Bits and bits instead of Drops and drops.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c13 c12">// Number of bits</span></p><p class="c5"><span class="c8">#define</span><span class="c10">&nbsp;BITS </span><span class="c3 c12">80</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">// struct for steam6</span></p><p class="c5"><span class="c10">struct</span><span class="c0">&nbsp;</span><span class="c4">Bit</span><span class="c0 c12">&nbsp;{</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c2">dist</span><span class="c0">;</span><span class="c13 c12">&nbsp; // Distance from the center of the screen.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c2">angle</span><span class="c0">;</span><span class="c13 c12">&nbsp;// Angle that the bit is moving away from the center at.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">speed</span><span class="c0">;</span><span class="c13 c12">&nbsp; // Speed that the bit is moving.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">color</span><span class="c0">;</span><span class="c13 c12">&nbsp; // Color index into the palette to draw this bit with.</span></p><p class="c5"><span class="c0 c12">};</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">// Colored bits from the center.</span></p><p class="c5"><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c11">mode_steam6</span><span class="c0">(</span><span class="c10">void</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c13 c12">&nbsp; // Clear all the LEDS</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">fill</span><span class="c0">(</span><span class="c11">bg</span><span class="c0 c12">());</span></p><p class="c5"><span class="c0 c12">&nbsp;</span></p><p class="c5"><span class="c13 c12">&nbsp; // Allocate memory for the bits data.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c1">!</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">allocateData</span><span class="c0">(</span><span class="c10">sizeof</span><span class="c0">(</span><span class="c4">Bit</span><span class="c0">) </span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0 c12">))</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">return</span><span class="c0">&nbsp;</span><span class="c11">mode_static</span><span class="c0">();</span><span class="c13 c12">&nbsp;//allocation failed</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">Bit</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c2">bits</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">reinterpret_cast</span><span class="c1">&lt;</span><span class="c4">Bit</span><span class="c1">*&gt;</span><span class="c0">(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">data</span><span class="c0 c12">);</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">return</span><span class="c0">&nbsp;</span><span class="c10">FRAMETIME</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">}</span><span class="c13 c12">&nbsp; </span></p><p class="c16 c18"><span class="c7"></span></p><h3 class="c20" id="h.x9jl1f137agb"><span class="c25 c12">Initializing the Bits</span></h3><p class="c16"><span>Next we initialize the bits on call 0. &nbsp;Note that all the bits start at dist=0 which is the center of the screen. &nbsp;The bits have random angles so will go in all different directions and at different speeds and colors. &nbsp;The angle here is not in any normal units but rather represented by a 16bit number where 0 is pointing to the right and the angle sweeps around until 2</span><span class="c32">16</span><span class="c7">&nbsp;- 1 is almost pointing to the right again.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c13 c12">&nbsp; // Initialize the bits on the first call.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">call</span><span class="c0">&nbsp;</span><span class="c1">==</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">dist</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">angle</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random16</span><span class="c0 c12">();</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">10</span><span class="c0">) </span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">1</span><span class="c0">;</span><span class="c13 c12">&nbsp; // 1 - 10</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">();</span><span class="c13 c12">&nbsp;// 0 - 255</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c16 c18"><span class="c7"></span></p><h3 class="c20" id="h.12ztdbxpuse9"><span class="c25 c12">Drawing the bits</span></h3><p class="c16"><span>Now that the data is initialized we can draw all the bits. &nbsp;The math to convert the dist and angle to x and y is a bit complicated but the basic math is x = dist * cos(angle) and y = dist * sin(angle) there is some funny scaling because the sin and cos we use generate +/- 2</span><span class="c32">15</span><span class="c7">&nbsp;instead of the normal -1 to +1.</span></p><p class="c5"><span class="c13 c12">&nbsp; // Draw all the bits.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">offscreen</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">int8_t</span><span class="c0">&nbsp;</span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;(</span><span class="c4">int8_t</span><span class="c0">)((((</span><span class="c4">int32_t</span><span class="c0">)</span><span class="c11">cos16_t</span><span class="c0">(</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">angle</span><span class="c0">)) </span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">dist</span><span class="c0">) </span><span class="c1">/</span><span class="c0">&nbsp;</span><span class="c3">0xFFFF</span><span class="c0">&nbsp;</span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">10</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">int8_t</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;(</span><span class="c4">int8_t</span><span class="c0">)((((</span><span class="c4">int32_t</span><span class="c0">)</span><span class="c11">sin16_t</span><span class="c0">(</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">angle</span><span class="c0">)) </span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">dist</span><span class="c0">) </span><span class="c1">/</span><span class="c0">&nbsp;</span><span class="c3">0xFFFF</span><span class="c0">&nbsp;</span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">10</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">c</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">color_from_palette</span><span class="c0">(</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">, </span><span class="c10">false</span><span class="c0">, </span><span class="c10">true</span><span class="c0">, </span><span class="c3">3</span><span class="c0 c12">);</span></p><p class="c5"><span class="c13 c12">&nbsp; &nbsp; // Check if the bit is on the screen.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">&gt;=</span><span class="c3">0</span><span class="c0">&nbsp;</span><span class="c1">&amp;&amp;</span><span class="c0">&nbsp;</span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">&nbsp;</span><span class="c1">&amp;&amp;</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&gt;=</span><span class="c3">0</span><span class="c0">&nbsp;</span><span class="c1">&amp;&amp;</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">setPixelColorXY</span><span class="c0">(</span><span class="c2">x</span><span class="c0">, </span><span class="c2">y</span><span class="c0">, </span><span class="c2">c</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; } </span><span class="c8">else</span><span class="c0 c12">&nbsp;{</span></p><p class="c5"><span class="c13 c12">&nbsp; &nbsp; &nbsp; // Remember this bit was off screen.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">offscreen</span><span class="c1">++</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c16"><span class="c7">The code above also creates a new variable called &ldquo;offscreen&rdquo; which keeps up with how many bits were not on the screen anymore. &nbsp;Once all the bits move off the screen we will start the animation over.</span></p><h3 class="c20" id="h.mnndc9xsk8es"><span class="c25 c12">Moving the Bits</span></h3><p class="c16"><span>Just like in task 5 we set up a counter and detect when the counter ticks over to a new value. &nbsp;Then if all the bits are off the screen then we reset them to new random values and the center of the screen. &nbsp;Otherwise if the clock is ticking then we increment the dist for each bit to move it outward.</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c13 c12">&nbsp; // Setup a clock based on the speed and update bits only when it ticks over.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;(</span><span class="c2">strip</span><span class="c0">.</span><span class="c2">now</span><span class="c0">&nbsp;</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">speed</span><span class="c0">) </span><span class="c1">&gt;&gt;</span><span class="c0">&nbsp;</span><span class="c3">14</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c10">bool</span><span class="c0">&nbsp;</span><span class="c2">tick</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">false</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">step</span><span class="c0">&nbsp;</span><span class="c1">!=</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c2">tick</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">true</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">step</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">&nbsp; // If all the bits are off the screen then reset all the bits.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c2">offscreen</span><span class="c0">&nbsp;</span><span class="c1">&gt;=</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">dist</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">angle</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random16</span><span class="c0 c12">();</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">10</span><span class="c0">) </span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">1</span><span class="c0">;</span><span class="c13 c12">&nbsp; // 1 - 10</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">();</span><span class="c13 c12">&nbsp;// 0 - 255</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c13 c12">&nbsp; // Else if the clock ticked then move the bits outward.</span></p><p class="c5"><span class="c0">&nbsp; } </span><span class="c8">else</span><span class="c0">&nbsp;</span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c2">tick</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">dist</span><span class="c0">&nbsp;</span><span class="c1">+=</span><span class="c0">&nbsp;</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><hr style="page-break-before:always;display:none;"><p class="c16 c18"><span class="c7"></span></p><h3 class="c20" id="h.cwsl7y6je6zz"><span class="c25 c12">Final Version</span></h3><p class="c16"><span class="c7">Putting it all together the final code is:</span></p><p class="c16 c18"><span class="c7"></span></p><p class="c5"><span class="c13 c12">// Number of bits</span></p><p class="c5"><span class="c8">#define</span><span class="c10">&nbsp;BITS </span><span class="c3 c12">80</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">// struct for steam6</span></p><p class="c5"><span class="c10">struct</span><span class="c0">&nbsp;</span><span class="c4">Bit</span><span class="c0 c12">&nbsp;{</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c2">dist</span><span class="c0">;</span><span class="c13 c12">&nbsp; // Distance from the center of the screen.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c2">angle</span><span class="c0">;</span><span class="c13 c12">&nbsp;// Angle that the bit is moving away from the center at.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">speed</span><span class="c0">;</span><span class="c13 c12">&nbsp; // Speed that the bit is moving.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint8_t</span><span class="c0">&nbsp;</span><span class="c2">color</span><span class="c0">;</span><span class="c13 c12">&nbsp; // Color index into the palette to draw this bit with.</span></p><p class="c5"><span class="c0 c12">};</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">// Colored bits from the center.</span></p><p class="c5"><span class="c4">uint16_t</span><span class="c0">&nbsp;</span><span class="c11">mode_steam6</span><span class="c0">(</span><span class="c10">void</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c13 c12">&nbsp; // Clear all the LEDS</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">fill</span><span class="c0">(</span><span class="c11">bg</span><span class="c0 c12">());</span></p><p class="c5"><span class="c0 c12">&nbsp;</span></p><p class="c5"><span class="c13 c12">&nbsp; // Allocate memory for the bits data.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c1">!</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">allocateData</span><span class="c0">(</span><span class="c10">sizeof</span><span class="c0">(</span><span class="c4">Bit</span><span class="c0">) </span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0 c12">))</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">return</span><span class="c0">&nbsp;</span><span class="c11">mode_static</span><span class="c0">();</span><span class="c13 c12">&nbsp;//allocation failed</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">Bit</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c2">bits</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">reinterpret_cast</span><span class="c1">&lt;</span><span class="c4">Bit</span><span class="c1">*&gt;</span><span class="c0">(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">data</span><span class="c0 c12">);</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">&nbsp; // Initialize the bits on the first call.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">call</span><span class="c0">&nbsp;</span><span class="c1">==</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">dist</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">angle</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random16</span><span class="c0 c12">();</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">10</span><span class="c0">) </span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">1</span><span class="c0">;</span><span class="c13 c12">&nbsp; // 1 - 10</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">();</span><span class="c13 c12">&nbsp;// 0 - 255</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">&nbsp; // Draw all the bits.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">offscreen</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">int8_t</span><span class="c0">&nbsp;</span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;(</span><span class="c4">int8_t</span><span class="c0">)((((</span><span class="c4">int32_t</span><span class="c0">)</span><span class="c11">cos16_t</span><span class="c0">(</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">angle</span><span class="c0">)) </span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">dist</span><span class="c0">) </span><span class="c1">/</span><span class="c0">&nbsp;</span><span class="c3">0xFFFF</span><span class="c0">&nbsp;</span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">10</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">int8_t</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;(</span><span class="c4">int8_t</span><span class="c0">)((((</span><span class="c4">int32_t</span><span class="c0">)</span><span class="c11">sin16_t</span><span class="c0">(</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">angle</span><span class="c0">)) </span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">dist</span><span class="c0">) </span><span class="c1">/</span><span class="c0">&nbsp;</span><span class="c3">0xFFFF</span><span class="c0">&nbsp;</span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">10</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">c</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c11">color_from_palette</span><span class="c0">(</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">, </span><span class="c10">false</span><span class="c0">, </span><span class="c10">true</span><span class="c0">, </span><span class="c3">3</span><span class="c0 c12">);</span></p><p class="c5"><span class="c13 c12">&nbsp; &nbsp; // Check if the bit is on the screen.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">&gt;=</span><span class="c3">0</span><span class="c0">&nbsp;</span><span class="c1">&amp;&amp;</span><span class="c0">&nbsp;</span><span class="c2">x</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0">&nbsp;</span><span class="c1">&amp;&amp;</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&gt;=</span><span class="c3">0</span><span class="c0">&nbsp;</span><span class="c1">&amp;&amp;</span><span class="c0">&nbsp;</span><span class="c2">y</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c3">20</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">strip</span><span class="c0">.</span><span class="c11">setPixelColorXY</span><span class="c0">(</span><span class="c2">x</span><span class="c0">, </span><span class="c2">y</span><span class="c0">, </span><span class="c2">c</span><span class="c0 c12">);</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; } </span><span class="c8">else</span><span class="c0 c12">&nbsp;{</span></p><p class="c5"><span class="c13 c12">&nbsp; &nbsp; &nbsp; // Remember this bit was off screen.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">offscreen</span><span class="c1">++</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">&nbsp; // Setup a clock based on the speed and update bits only when it ticks over.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c4">uint32_t</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;(</span><span class="c2">strip</span><span class="c0">.</span><span class="c2">now</span><span class="c0">&nbsp;</span><span class="c1">*</span><span class="c0">&nbsp;</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">speed</span><span class="c0">) </span><span class="c1">&gt;&gt;</span><span class="c0">&nbsp;</span><span class="c3">14</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c10">bool</span><span class="c0">&nbsp;</span><span class="c2">tick</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">false</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">step</span><span class="c0">&nbsp;</span><span class="c1">!=</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c2">tick</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c10">true</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c10">SEGMENT</span><span class="c0">.</span><span class="c2">step</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c2">counter</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c13 c12">&nbsp; // If all the bits are off the screen then reset all the bits.</span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c2">offscreen</span><span class="c0">&nbsp;</span><span class="c1">&gt;=</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">dist</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c3">0</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">angle</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random16</span><span class="c0 c12">();</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">(</span><span class="c3">10</span><span class="c0">) </span><span class="c1">+</span><span class="c0">&nbsp;</span><span class="c3">1</span><span class="c0">;</span><span class="c13 c12">&nbsp; // 1 - 10</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">color</span><span class="c0">&nbsp;</span><span class="c1">=</span><span class="c0">&nbsp;</span><span class="c11">random8</span><span class="c0">();</span><span class="c13 c12">&nbsp;// 0 - 255</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c13 c12">&nbsp; // Else if the clock ticked then move the bits outward.</span></p><p class="c5"><span class="c0">&nbsp; } </span><span class="c8">else</span><span class="c0">&nbsp;</span><span class="c8">if</span><span class="c0">&nbsp;(</span><span class="c2">tick</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; </span><span class="c8">for</span><span class="c0">&nbsp;(</span><span class="c10">int</span><span class="c0">&nbsp;</span><span class="c2">i</span><span class="c1">=</span><span class="c3">0</span><span class="c0">; </span><span class="c2">i</span><span class="c0">&nbsp;</span><span class="c1">&lt;</span><span class="c0">&nbsp;</span><span class="c10">BITS</span><span class="c0">; </span><span class="c2">i</span><span class="c1">++</span><span class="c0 c12">) {</span></p><p class="c5"><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">dist</span><span class="c0">&nbsp;</span><span class="c1">+=</span><span class="c0">&nbsp;</span><span class="c2">bits</span><span class="c0">[</span><span class="c2">i</span><span class="c0">].</span><span class="c2">speed</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0 c12">&nbsp; }</span></p><p class="c5 c18"><span class="c0 c12"></span></p><p class="c5"><span class="c0">&nbsp; </span><span class="c8">return</span><span class="c0">&nbsp;</span><span class="c10">FRAMETIME</span><span class="c0 c12">;</span></p><p class="c5"><span class="c0 c12">}</span></p><p class="c16 c18"><span class="c7"></span></p></body></html>